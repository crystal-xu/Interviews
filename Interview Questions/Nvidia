1. set & unordered_set底层数据结构有什么区别？set中insert一个key，查找算法是DFS还是BFS？
red black tree;  hash table
DFS

2. 进程通信方式？进程同步方式？
PIPE, FIFO, SOCKET, Shared memory, Semophore

3. 进程调度算法？
先来先服务
先来先服务调度算法（First Come First Served, FCFS）是最简单的调度算法，可以用于作业调度和进程调度。
按照作业进入系统后备作业队列的先后次序来挑选作业，加入就绪队列，等待执行。
FCFS是非抢占式的，易于实现，效率不高，性能不好，有利于长作业（CPU繁忙性）而不利于短作业（I/O繁忙性）。

短作业优先
短作业优先调度算法（Short Job First）用于进程调度时又被称为短进程优先调度算法（Short Process First），该算法既可以用于作业调度，又可以用于进程调度。
在作业调度中，该算法每次从后备作业队列中挑选估计服务时间最短的一个或几个作业，将他们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中的原理类似。
SJF是非抢占式的，优先照顾短作业，具有很好的性能，降低平均等待时间，提高吞吐量。但是不利于长作业，长作业可能一直处于等待状态，出现饥饿现象；完全未考虑作业的优先紧迫程度，不能用于实时系统。

最短剩余时间优先
SJF本身是非抢占式的，用于抢占式调度系统时，对应的算法称为最短剩余时间优先调度算法。
该算法首先按照作业的服务时间挑选最短的作业运行，在该作业运行期间，一旦有新作业到达系统，并且该新作业的服务时间比当前运行作业的剩余服务时间短，则发生抢占；否则，当前作业继续运行。该算法确保
一旦新的短作业或短进程进入系统，能够很快得到处理。
由于频繁的抢占和进程切换，系统开销大，该算法实现代价高，一般用于实时系统。

高响应比优先
高响应比优先调度算法（Highest Reponse Ratio First, HRRF）是非抢占式的，主要用于作业调度。
基本思想：每次进行作业调度时，先计算后备作业队列中每个作业的响应比，挑选最高的作业投入系统运行。
响应比 = （等待时间 + 服务时间） / 服务时间 = 等待时间 / 服务时间 + 1
由响应比分析可知，该算法介于FCFS和SJF之间，但是每次需要计算每个作业的响应比，增加系统开销。

时间片轮转
用于分时系统的进程调度。
基本思想：系统将CPU处理时间划分为若干个时间片（q），进程按照到达先后顺序排列。每次调度选择队首的进程，执行完1个时间片q后，计时器发出时钟中断请求，该进程移至队尾。以后每次调度都是如此。
该算法能在给定的时间内响应所有用户的而请求，达到分时系统的目的。
其性能主要取决于时间片q的大小，q太大，则所有的进程在1个时间片完成，退外围FCFS；太小则进程频繁切换，系统开销大。
该算法简单有效，常用于分时系统，但不利于I/O频繁的而紧凑，由于这种进程用不完一个时间片，就因为等待I/O操作而被阻塞，当I/O操作结束后，只能插入到就绪队列的末尾，等待下一轮调度。

4. 线程通信方式？线程同步方式？
跨进程、不跨进程
Mutex

5. 进程和线程有什么区别？

6. C++的三个基本特性？多态性是如何实现的？

7. 内存分配方式有哪些？

